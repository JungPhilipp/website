<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C | Philipp Jung</title>
    <link>http://philipp-jung.de/tags/c/</link>
      <atom:link href="http://philipp-jung.de/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <description>C</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 05 Feb 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>C</title>
      <link>http://philipp-jung.de/tags/c/</link>
    </image>
    
    <item>
      <title>Using modern CMake to test private C&#43;&#43; implementation files</title>
      <link>http://philipp-jung.de/post/testing_private_impl_files/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      <guid>http://philipp-jung.de/post/testing_private_impl_files/</guid>
      <description>&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;When writing C++ code, I often find myself wanting to write tests for private implementation files. Consider a small example project with the following folder structure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;component&amp;gt;
├── include
│   └── src.h
├── private_include
│   └── private_impl.h
├── src
│   ├── src.cpp
│   └── private_impl.cpp
├── test
│   ├── test.t.cpp
│   └── CMakeLists.txt
└── CMakeLists.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where the top-level &lt;code&gt;CMakeLists.txt&lt;/code&gt; could look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_library(&amp;lt;component_target&amp;gt; SHARED src/src.cpp src/private_impl.cpp)
target_include_directories (&amp;lt;component_target&amp;gt; PRIVATE include)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the &lt;code&gt;test/CMakeLists.txt&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_executable(&amp;lt;test_target&amp;gt; test.t.cpp)
target_link_libraries(&amp;lt;test_target&amp;gt; PUBLIC &amp;lt;component_target&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When writing tests in &lt;code&gt;test/test.t.cpp&lt;/code&gt;, how can we access private implementations from the &lt;code&gt;private_include&lt;/code&gt; directory?&lt;/p&gt;
&lt;h3 id=&#34;the-pitfall-solution&#34;&gt;The &amp;ldquo;pitfall&amp;rdquo; solution&lt;/h3&gt;
&lt;p&gt;I have seen people do things, like including the relevant source file in their sources.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# This is the wrong thing to do
SET (SOURCES 
      ../src/private_impl.cpp
      test.t.cpp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a bad solution for several reasons.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, the implementation in &lt;code&gt;src/private_impl.cpp&lt;/code&gt; is used outside the original component, e.g., link dependencies may no longer be satisfied.&lt;/li&gt;
&lt;li&gt;Second, oftentimes there exists some logic (within CMake or otherwise) that sets context (like macros) depending on the current component. With the &amp;ldquo;patch&amp;rdquo; from before we now test &lt;code&gt;private_impl.cpp&lt;/code&gt; in another context than it is normally used in.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;a-better-solution&#34;&gt;A better solution&lt;/h3&gt;
&lt;p&gt;Luckily, modern CMake has our back. We can explicitly model the depency on the private implementation of &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt;, since we already specify all required information within the top level &lt;code&gt;CMakeLists.txt&lt;/code&gt;. We simply need to access this information within our test environment.
This can be done using CMakes property system, i.e., we can get the necessary properties from &lt;code&gt;&amp;lt;component_target&amp;gt;&lt;/code&gt; and reuse them for &lt;code&gt;&amp;lt;test_target&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_executable(&amp;lt;test_target&amp;gt; test.t.cpp)
target_link_libraries(&amp;lt;test_target&amp;gt; PRIVATE &amp;lt;component_target&amp;gt;)

get_target_property (private_include_dirs &amp;lt;test_target&amp;gt; INCLUDE_DIRECTORIES)
get_target_property (private_link_libraries &amp;lt;test_target&amp;gt; LINK_LIBRARIES)

target_include_directories (&amp;lt;test_target&amp;gt; PRIVATE ${private_include_dirs})
target_link_libraries (&amp;lt;test_target&amp;gt; PRIVATE ${private_link_libraries})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way, we make sure that we use the content of &lt;code&gt;private_impl.cpp&lt;/code&gt; in the right context. We furthermore explicitly express the link dependency between our &lt;code&gt;&amp;lt;test_target&amp;gt;&lt;/code&gt; and the corresponding &lt;code&gt;&amp;lt;component_target&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;symbol-visibility--fvisibilityhidden1&#34;&gt;Symbol Visibility (-fvisibility=hidden)&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;If you are hiding ELF symbols by default (which you should), this method has the drawback that symbols from &lt;code&gt;private_impl.h&lt;/code&gt; you are testing need to be marked as exported, so the linker can find them when linking &lt;code&gt;&amp;lt;test_target&amp;gt;&lt;/code&gt;. This is done by specifying&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;__attribute__ ((visibility (&amp;quot;default&amp;quot;)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;for the symbol in question. Both GCC and Clang support this syntax.
As a side note, with modern CMake versions &amp;gt; 3.0.2, you can auto generate a cross platform export definition using &lt;code&gt;GenerateExportHeader&lt;/code&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;See my other post on symbol visibility if you want to dive deeper into this topic.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/wiki/Visibility&#34;&gt;https://gcc.gnu.org/wiki/Visibility&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://cmake.org/cmake/help/v3.0/module/GenerateExportHeader.html&#34;&gt;https://cmake.org/cmake/help/v3.0/module/GenerateExportHeader.html&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
