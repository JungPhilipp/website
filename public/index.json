[{"authors":["philippjung"],"categories":null,"content":"Welcome to my personal website. I am a Software Engineer at Volume Graphics , in Heidelberg, Germany. Previously, I obtained my bachelor\u0026rsquo;s and master\u0026rsquo;s degree in Computer Science from Heidelberg University.\nYou can find my contact info on the contact tab. This site contains information about my career and various things I am interested in, including a small blog where I post about C++, CMake, Rust, and other technical topics.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1581153079,"objectID":"6bbf2282c363ec8a3073fbc4ce673d95","permalink":"http://philipp-jung.de/authors/philippjung/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/philippjung/","section":"authors","summary":"Welcome to my personal website. I am a Software Engineer at Volume Graphics , in Heidelberg, Germany. Previously, I obtained my bachelor\u0026rsquo;s and master\u0026rsquo;s degree in Computer Science from Heidelberg University.\nYou can find my contact info on the contact tab. This site contains information about my career and various things I am interested in, including a small blog where I post about C++, CMake, Rust, and other technical topics.","tags":null,"title":"Philipp Jung","type":"authors"},{"authors":["Philipp Jung"],"categories":null,"content":"Why Configuration as Code? I have been using Jenkins heavily for automation and CI/CD tasks over the last year. Pretty fast I got excited and started automating as many of my regular tasks as possible. And Jenkins is a great tool for that. However, soon I realized that the state of my Jenkins server was hard to reproduce, and should my infrastructure ever fail, there wouldn\u0026rsquo;t be an easy way to get back to my current configuration. Sure, I had a regular backup of the Jenkins configuration (i.e., Jenkins home). But those are mainly XML files that are hard to read and almost impossible to maintain. The solution: Use declarative pipelines, i.e., Jenkinsfiles, that are tracked by git (or any other SCM). This way at least the jobs themselves are backed up. But what about the rest of the Jenkins configuration: Plugins, credentials or libraries. As of 2018 there exist Jenkins Configuration as Code (JCasC), which uses easy to understand yaml files to capture the Jenkins configuration. In the following we will see how such a basic configuration could look like. And as a little bonus, we can even script the \u0026ldquo;seed\u0026rdquo; jobs that use Jenkinsfile from SCM checkouts using the job-dsl plugin\n","date":1591920000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592136960,"objectID":"76f1879e2515a0c704ac9b8145738690","permalink":"http://philipp-jung.de/post/jenkins_configuration_as_code_with_docker_compose/","publishdate":"2020-06-12T00:00:00Z","relpermalink":"/post/jenkins_configuration_as_code_with_docker_compose/","section":"post","summary":"How to setup a Jenkins server with Docker Compose and Jenkins Configuration as Code (JCasC)","tags":["Jenkins","Docker","Docker-Compose","Infrastructure as code"],"title":"Jenkins Configuration as Code with Docker Compose","type":"post"},{"authors":["Philipp Jung"],"categories":null,"content":"The Problem When writing C++ code, I often find myself wanting to write tests for private implementation files. Consider a small example project with the following folder structure:\n\u0026lt;component\u0026gt; ├── include │ └── src.h ├── private_include │ └── private_impl.h ├── src │ ├── src.cpp │ └── private_impl.cpp ├── test │ ├── test.t.cpp │ └── CMakeLists.txt └── CMakeLists.txt  Where the top-level CMakeLists.txt could look something like this:\nadd_library(\u0026lt;component_target\u0026gt; SHARED src/src.cpp src/private_impl.cpp) target_include_directories (\u0026lt;component_target\u0026gt; PRIVATE include)  and the test/CMakeLists.txt like this:\nadd_executable(\u0026lt;test_target\u0026gt; test.t.cpp) target_link_libraries(\u0026lt;test_target\u0026gt; PUBLIC \u0026lt;component_target\u0026gt;)  When writing tests in test/test.t.cpp, how can we access private implementations from the private_include directory?\nThe \u0026ldquo;pitfall\u0026rdquo; solution I have seen people do things, like including the relevant source file in their sources.\n# This is the wrong thing to do SET (SOURCES ../src/private_impl.cpp test.t.cpp)  This is a bad solution for several reasons.\n First, the implementation in src/private_impl.cpp is used outside the original component, e.g., link dependencies may no longer be satisfied. Second, oftentimes there exists some logic (within CMake or otherwise) that sets context (like macros) depending on the current component. With the \u0026ldquo;patch\u0026rdquo; from before we now test private_impl.cpp in another context than it is normally used in.  A better solution Luckily, modern CMake has our back. We can explicitly model the depency on the private implementation of \u0026lt;component\u0026gt;, since we already specify all required information within the top level CMakeLists.txt. We simply need to access this information within our test environment. This can be done using CMakes property system, i.e., we can get the necessary properties from \u0026lt;component_target\u0026gt; and reuse them for \u0026lt;test_target\u0026gt;:\nadd_executable(\u0026lt;test_target\u0026gt; test.t.cpp) target_link_libraries(\u0026lt;test_target\u0026gt; PRIVATE \u0026lt;component_target\u0026gt;) get_target_property (private_include_dirs \u0026lt;test_target\u0026gt; INCLUDE_DIRECTORIES) get_target_property (private_link_libraries \u0026lt;test_target\u0026gt; LINK_LIBRARIES) target_include_directories (\u0026lt;test_target\u0026gt; PRIVATE ${private_include_dirs}) target_link_libraries (\u0026lt;test_target\u0026gt; PRIVATE ${private_link_libraries})  This way, we make sure that we use the content of private_impl.cpp in the right context. We furthermore explicitly express the link dependency between our \u0026lt;test_target\u0026gt; and the corresponding \u0026lt;component_target\u0026gt;.\nSymbol Visibility (-fvisibility=hidden)1 If you are hiding ELF symbols by default (which you should), this method has the drawback that symbols from private_impl.h you are testing need to be marked as exported, so the linker can find them when linking \u0026lt;test_target\u0026gt;. This is done by specifying\n __attribute__ ((visibility (\u0026quot;default\u0026quot;)))\n for the symbol in question. Both GCC and Clang support this syntax. As a side note, with modern CMake versions \u0026gt; 3.0.2, you can auto generate a cross platform export definition using GenerateExportHeader2\nSee my other post on symbol visibility if you want to dive deeper into this topic.\n  https://gcc.gnu.org/wiki/Visibility \u0026#x21a9;\u0026#xfe0e;\n https://cmake.org/cmake/help/v3.0/module/GenerateExportHeader.html \u0026#x21a9;\u0026#xfe0e;\n   ","date":1580860800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580928287,"objectID":"c0c193c0bb7e75c908f1507e353a5694","permalink":"http://philipp-jung.de/post/testing_private_impl_files/","publishdate":"2020-02-05T00:00:00Z","relpermalink":"/post/testing_private_impl_files/","section":"post","summary":"Using modern CMake to test private C/C++ implementation files without exposing them to the library user.","tags":["C++","C","CMake","Linux"],"title":"Using modern CMake to test private C++ implementation files","type":"post"},{"authors":null,"categories":null,"content":"If not specified otherwise, all content has been created by Philipp Jung and is licenced under a Creative Commons Attribution 3.0 Unported Licence .\n\u0026ldquo;In Germany, websites are required by law to show some address information about their owners. As a courtesy towards the smart politicians who crusaded for this law, I am including this information.\u0026rdquo;\nThanks to Bastian Rieck for that little comment ;)\n—–BEGIN GERMAN LEGAL MUMBO-JUMBO—–\n Verantwortlich für diese Webseite ist im Sinne aller geltenden deutschen Gesetze:\nPhilipp Jung Karlsruher Str. 48 69126 Heidelberg\nphilippjung@mailbox.org\n —–END GERMAN LEGAL MUMBO-JUMBO—\n","date":1530140400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580921452,"objectID":"9b10c1f64082d3869fd4cb1f85809430","permalink":"http://philipp-jung.de/terms/","publishdate":"2018-06-28T00:00:00+01:00","relpermalink":"/terms/","section":"","summary":"If not specified otherwise, all content has been created by Philipp Jung and is licenced under a Creative Commons Attribution 3.0 Unported Licence .\n\u0026ldquo;In Germany, websites are required by law to show some address information about their owners. As a courtesy towards the smart politicians who crusaded for this law, I am including this information.\u0026rdquo;\nThanks to Bastian Rieck for that little comment ;)\n—–BEGIN GERMAN LEGAL MUMBO-JUMBO—–\n Verantwortlich für diese Webseite ist im Sinne aller geltenden deutschen Gesetze:","tags":null,"title":"Terms","type":"page"}]